---
sidebar: sidebar 
permalink: trident-reco/security-luks.html 
keywords: security, luks, linux unified key setup, encryption, key rotation, resizing, advanced encryption, rotation, key, import 
summary: 'Trident 에서 ONTAP SAN 및 ONTAP SAN ECONOMY 볼륨을 암호화하기 위해 Linux Unified Key Setup(LUKS)을 활성화할 수 있습니다.  Trident LUKS로 암호화된 볼륨에 대한 볼륨 크기 조정 및 키(암호) 순환을 지원합니다.' 
---
= Linux 통합 키 설정(LUKS)
:hardbreaks:
:allow-uri-read: 
:icons: font
:imagesdir: ../media/


[role="lead"]
Trident 에서 ONTAP SAN 및 ONTAP SAN ECONOMY 볼륨을 암호화하기 위해 Linux Unified Key Setup(LUKS)을 활성화할 수 있습니다.  Trident LUKS로 암호화된 볼륨에 대한 암호 문구 순환과 볼륨 확장을 지원합니다.

Trident 에서 LUKS 암호화 볼륨은 권장하는 대로 aes-xts-plain64 암호 및 모드를 사용합니다.link:https://csrc.nist.gov/publications/detail/sp/800-38e/final["미국 국립표준기술원(NIST)"^] .


NOTE: ASA r2 시스템에서는 LUKS 암호화가 지원되지 않습니다.  ASA r2 시스템에 대한 정보는 다음을 참조하세요.link:https://docs.netapp.com/us-en/asa-r2/get-started/learn-about.html["ASA r2 스토리지 시스템에 대해 알아보세요"^] .

.시작하기 전에
* 작업자 노드에는 cryptsetup 2.1 이상(3.0 미만)이 설치되어 있어야 합니다.  자세한 내용은 다음을 방문하세요.link:https://gitlab.com/cryptsetup/cryptsetup["Gitlab: cryptsetup"^] .
* 성능상의 이유로 NetApp 작업자 노드가 AES-NI(Advanced Encryption Standard New Instructions)를 지원할 것을 권장합니다.  AES-NI 지원을 확인하려면 다음 명령을 실행하세요.
+
[listing]
----
grep "aes" /proc/cpuinfo
----
+
아무것도 반환되지 않으면 프로세서가 AES-NI를 지원하지 않는 것입니다.  AES-NI에 대한 자세한 내용은 다음을 방문하세요.link:https://www.intel.com/content/www/us/en/developer/articles/technical/advanced-encryption-standard-instructions-aes-ni.html["Intel: 고급 암호화 표준 명령어(AES-NI)"^] .





== LUKS 암호화 활성화

ONTAP SAN 및 ONTAP SAN ECONOMY 볼륨에 대해 Linux Unified Key Setup(LUKS)을 사용하여 볼륨별 호스트 측 암호화를 활성화할 수 있습니다.

.단계
. 백엔드 구성에서 LUKS 암호화 속성을 정의합니다.  ONTAP SAN의 백엔드 구성 옵션에 대한 자세한 내용은 다음을 참조하세요.link:../trident-use/ontap-san-examples.html["ONTAP SAN 구성 옵션"] .
+
[source, json]
----
{
  "storage": [
    {
      "labels": {
        "luks": "true"
      },
      "zone": "us_east_1a",
      "defaults": {
        "luksEncryption": "true"
      }
    },
    {
      "labels": {
        "luks": "false"
      },
      "zone": "us_east_1a",
      "defaults": {
        "luksEncryption": "false"
      }
    }
  ]
}
----
. 사용 `parameters.selector` LUKS 암호화를 사용하여 스토리지 풀을 정의합니다. 예를 들어:
+
[source, yaml]
----
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: luks
provisioner: csi.trident.netapp.io
parameters:
  selector: "luks=true"
  csi.storage.k8s.io/node-stage-secret-name: luks-${pvc.name}
  csi.storage.k8s.io/node-stage-secret-namespace: ${pvc.namespace}
----
. LUKS 암호문구를 포함하는 비밀번호를 생성합니다. 예를 들어:
+
[source, yaml]
----
kubectl -n trident create -f luks-pvc1.yaml
apiVersion: v1
kind: Secret
metadata:
  name: luks-pvc1
stringData:
  luks-passphrase-name: A
  luks-passphrase: secretA
----




=== 제한 사항

LUKS 암호화 볼륨은 ONTAP 중복 제거 및 압축 기능을 활용할 수 없습니다.



== LUKS 볼륨 가져오기를 위한 백엔드 구성

LUKS 볼륨을 가져오려면 다음을 설정해야 합니다. `luksEncryption` 에게(`true` 백엔드에서.  그만큼 `luksEncryption` 옵션은 볼륨이 LUKS 규격인지 Trident 알려줍니다.(`true` ) 또는 LUKS 규격에 맞지 않음(`false` ) 다음 예와 같습니다.

[source, yaml]
----
version: 1
storageDriverName: ontap-san
managementLIF: 10.0.0.1
dataLIF: 10.0.0.2
svm: trident_svm
username: admin
password: password
defaults:
  luksEncryption: 'true'
  spaceAllocation: 'false'
  snapshotPolicy: default
  snapshotReserve: '10'
----


== LUKS 볼륨 가져오기를 위한 PVC 구성

LUKS 볼륨을 동적으로 가져오려면 주석을 설정하세요. `trident.netapp.io/luksEncryption` 에게 `true` 이 예에서 보여지는 것처럼 PVC에 LUKS 지원 스토리지 클래스를 포함합니다.

[source, yaml]
----
kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: luks-pvc
  namespace: trident
  annotations:
    trident.netapp.io/luksEncryption: "true"
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
  storageClassName: luks-sc
----


== LUKS 암호 문구 회전

LUKS 암호를 교체하고 교체를 확인할 수 있습니다.


WARNING: 볼륨, 스냅샷 또는 비밀에서 더 이상 참조되지 않는다는 것을 확인할 때까지 암호를 잊지 마세요.  참조된 암호문구가 손실되면 볼륨을 마운트할 수 없고 데이터는 암호화되어 액세스할 수 없게 됩니다.

.이 작업에 관하여
LUKS 암호 문구 순환은 새로운 LUKS 암호 문구가 지정된 후 볼륨을 마운트하는 포드가 생성될 때 발생합니다.  새로운 포드가 생성되면 Trident 볼륨의 LUKS 암호를 비밀의 활성 암호와 비교합니다.

* 볼륨의 암호가 비밀의 활성 암호와 일치하지 않으면 회전이 발생합니다.
* 볼륨의 암호가 비밀의 활성 암호와 일치하는 경우 `previous-luks-passphrase` 매개변수는 무시됩니다.


.단계
. 추가하세요 `node-publish-secret-name` 그리고 `node-publish-secret-namespace` StorageClass 매개변수. 예를 들어:
+
[source, yaml]
----
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: csi-san
provisioner: csi.trident.netapp.io
parameters:
  trident.netapp.io/backendType: "ontap-san"
  csi.storage.k8s.io/node-stage-secret-name: luks
  csi.storage.k8s.io/node-stage-secret-namespace: ${pvc.namespace}
  csi.storage.k8s.io/node-publish-secret-name: luks
  csi.storage.k8s.io/node-publish-secret-namespace: ${pvc.namespace}
----
. 볼륨이나 스냅샷에 있는 기존 암호를 식별합니다.
+
.용량
[listing]
----
tridentctl -d get volume luks-pvc1
GET http://127.0.0.1:8000/trident/v1/volume/<volumeID>

...luksPassphraseNames:["A"]
----
+
.스냅샷
[listing]
----
tridentctl -d get snapshot luks-pvc1
GET http://127.0.0.1:8000/trident/v1/volume/<volumeID>/<snapshotID>

...luksPassphraseNames:["A"]
----
. 볼륨의 LUKS 비밀번호를 업데이트하여 새 암호와 이전 암호구를 지정합니다.  보장하다 `previous-luke-passphrase-name` 그리고 `previous-luks-passphrase` 이전 암호문구와 일치합니다.
+
[source, yaml]
----
apiVersion: v1
kind: Secret
metadata:
  name: luks-pvc1
stringData:
  luks-passphrase-name: B
  luks-passphrase: secretB
  previous-luks-passphrase-name: A
  previous-luks-passphrase: secretA
----
. 볼륨을 마운트하여 새로운 포드를 만듭니다.  이는 회전을 시작하는 데 필요합니다.
. 암호가 회전되었는지 확인하세요.
+
.용량
[listing]
----
tridentctl -d get volume luks-pvc1
GET http://127.0.0.1:8000/trident/v1/volume/<volumeID>

...luksPassphraseNames:["B"]
----
+
.스냅샷
[listing]
----
tridentctl -d get snapshot luks-pvc1
GET http://127.0.0.1:8000/trident/v1/volume/<volumeID>/<snapshotID>

...luksPassphraseNames:["B"]
----


.결과
볼륨과 스냅샷에 새로운 암호문구만 반환되면 암호문구가 회전되었습니다.


NOTE: 예를 들어 두 개의 암호가 반환되는 경우 `luksPassphraseNames: ["B", "A"]` , 회전이 완료되지 않았습니다.  새로운 포드를 작동시켜 회전을 완료할 수 있습니다.



== 볼륨 확장 활성화

LUKS로 암호화된 볼륨에서 볼륨 확장을 활성화할 수 있습니다.

.단계
. 활성화 `CSINodeExpandSecret` 기능 게이트(베타 1.25+). 참조하다 link:https://kubernetes.io/blog/2022/09/21/kubernetes-1-25-use-secrets-while-expanding-csi-volumes-on-node-alpha/["Kubernetes 1.25: CSI 볼륨의 노드 기반 확장을 위한 비밀 사용"^] 자세한 내용은.
. 추가하세요 `node-expand-secret-name` 그리고 `node-expand-secret-namespace` StorageClass 매개변수. 예를 들어:
+
[source, yaml]
----
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: luks
provisioner: csi.trident.netapp.io
parameters:
  selector: "luks=true"
  csi.storage.k8s.io/node-stage-secret-name: luks-${pvc.name}
  csi.storage.k8s.io/node-stage-secret-namespace: ${pvc.namespace}
  csi.storage.k8s.io/node-expand-secret-name: luks-${pvc.name}
  csi.storage.k8s.io/node-expand-secret-namespace: ${pvc.namespace}
allowVolumeExpansion: true
----


.결과
온라인 스토리지 확장을 시작하면 kubelet은 드라이버에 적절한 자격 증명을 전달합니다.
