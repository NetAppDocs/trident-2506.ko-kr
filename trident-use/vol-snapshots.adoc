---
sidebar: sidebar 
permalink: trident-use/vol-snapshots.html 
keywords: volumes, on-demand volume snapshots, create snapshots, backends, kubernetes, create PVCs, PVCs, snapshot, volume snapshot, import snapshot, recover data 
summary: '영구 볼륨(PV)의 Kubernetes 볼륨 스냅샷을 사용하면 볼륨의 특정 시점 복사본을 만들 수 있습니다.  Trident 사용하여 생성된 볼륨의 스냅샷을 생성하고, Trident 외부에서 생성된 스냅샷을 가져오고, 기존 스냅샷에서 새 볼륨을 생성하고, 스냅샷에서 볼륨 데이터를 복구할 수 있습니다.' 
---
= 스냅샷 작업
:hardbreaks:
:allow-uri-read: 
:icons: font
:imagesdir: ../media/


[role="lead"]
영구 볼륨(PV)의 Kubernetes 볼륨 스냅샷을 사용하면 볼륨의 특정 시점 복사본을 만들 수 있습니다.  Trident 사용하여 생성된 볼륨의 스냅샷을 생성하고, Trident 외부에서 생성된 스냅샷을 가져오고, 기존 스냅샷에서 새 볼륨을 생성하고, 스냅샷에서 볼륨 데이터를 복구할 수 있습니다.



== 개요

볼륨 스냅샷은 다음에서 지원됩니다. `ontap-nas` , `ontap-nas-flexgroup` , `ontap-san` , `ontap-san-economy` , `solidfire-san` , `gcp-cvs` , `azure-netapp-files` , 그리고 `google-cloud-netapp-volumes` 운전자.

.시작하기 전에
스냅샷을 사용하려면 외부 스냅샷 컨트롤러와 사용자 정의 리소스 정의(CRD)가 필요합니다.  이는 Kubernetes 오케스트레이터(예: Kubeadm, GKE, OpenShift)의 책임입니다.

Kubernetes 배포판에 스냅샷 컨트롤러 및 CRD가 포함되어 있지 않은 경우 다음을 참조하세요.<<볼륨 스냅샷 컨트롤러 배포>> .


NOTE: GKE 환경에서 주문형 볼륨 스냅샷을 생성하는 경우 스냅샷 컨트롤러를 생성하지 마세요.  GKE는 내장된 숨겨진 스냅샷 컨트롤러를 사용합니다.



== 볼륨 스냅샷 생성

.단계
. 생성하다 `VolumeSnapshotClass` 자세한 내용은 다음을 참조하세요.link:../trident-reference/objects.html#kubernetes-volumesnapshotclass-objects["볼륨 스냅샷 클래스"] .
+
** 그만큼 `driver` Trident CSI 드라이버를 가리킨다.
** `deletionPolicy`될 수 있다 `Delete` 또는 `Retain` .  설정 시 `Retain` , 스토리지 클러스터의 기본 물리적 스냅샷은 다음과 같은 경우에도 유지됩니다. `VolumeSnapshot` 객체가 삭제되었습니다.
+
.예
[listing]
----
cat snap-sc.yaml
----
+
[source, yaml]
----
apiVersion: snapshot.storage.k8s.io/v1
kind: VolumeSnapshotClass
metadata:
  name: csi-snapclass
driver: csi.trident.netapp.io
deletionPolicy: Delete
----


. 기존 PVC의 스냅샷을 만듭니다.
+
.예시
** 이 예제에서는 기존 PVC의 스냅샷을 만듭니다.
+
[listing]
----
cat snap.yaml
----
+
[source, yaml]
----
apiVersion: snapshot.storage.k8s.io/v1
kind: VolumeSnapshot
metadata:
  name: pvc1-snap
spec:
  volumeSnapshotClassName: csi-snapclass
  source:
    persistentVolumeClaimName: pvc1
----
** 이 예제에서는 PVC에 대한 볼륨 스냅샷 객체를 생성합니다. `pvc1` 그리고 스냅샷의 이름은 다음과 같이 설정됩니다. `pvc1-snap` .  VolumeSnapshot은 PVC와 유사하며 다음과 연관됩니다. `VolumeSnapshotContent` 실제 스냅샷을 나타내는 객체입니다.
+
[listing]
----
kubectl create -f snap.yaml
volumesnapshot.snapshot.storage.k8s.io/pvc1-snap created

kubectl get volumesnapshots
NAME                   AGE
pvc1-snap              50s
----
** 당신은 식별할 수 있습니다 `VolumeSnapshotContent` ~에 대한 객체 `pvc1-snap` VolumeSnapshot을 설명하여 보세요.  그만큼 `Snapshot Content Name` 이 스냅샷을 제공하는 VolumeSnapshotContent 객체를 식별합니다.  그만큼 `Ready To Use` 매개변수는 스냅샷을 사용하여 새로운 PVC를 생성할 수 있음을 나타냅니다.
+
[listing]
----
kubectl describe volumesnapshots pvc1-snap
Name:         pvc1-snap
Namespace:    default
...
Spec:
  Snapshot Class Name:    pvc1-snap
  Snapshot Content Name:  snapcontent-e8d8a0ca-9826-11e9-9807-525400f3f660
  Source:
    API Group:
    Kind:       PersistentVolumeClaim
    Name:       pvc1
Status:
  Creation Time:  2019-06-26T15:27:29Z
  Ready To Use:   true
  Restore Size:   3Gi
...
----






== 볼륨 스냅샷에서 PVC 생성

사용할 수 있습니다 `dataSource` VolumeSnapshot이라는 이름을 사용하여 PVC를 생성하려면 `<pvc-name>` 데이터의 출처로서.  PVC를 만든 후에는 포드에 부착하여 다른 PVC와 마찬가지로 사용할 수 있습니다.


WARNING: PVC는 소스 볼륨과 동일한 백엔드에 생성됩니다. 참조하다link:https://kb.netapp.com/Cloud/Astra/Trident/Creating_a_PVC_from_a_Trident_PVC_Snapshot_cannot_be_created_in_an_alternate_backend["KB: Trident PVC 스냅샷에서 PVC를 생성하는 작업은 대체 백엔드에서 생성할 수 없습니다."^] .

다음 예제에서는 다음을 사용하여 PVC를 생성합니다. `pvc1-snap` 데이터 소스로.

[listing]
----
cat pvc-from-snap.yaml
----
[source, yaml]
----
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pvc-from-snap
spec:
  accessModes:
    - ReadWriteOnce
  storageClassName: golden
  resources:
    requests:
      storage: 3Gi
  dataSource:
    name: pvc1-snap
    kind: VolumeSnapshot
    apiGroup: snapshot.storage.k8s.io
----


== 볼륨 스냅샷 가져오기

Trident 다음을 지원합니다.link:https://kubernetes.io/docs/concepts/storage/volume-snapshots/#static["Kubernetes 사전 프로비저닝 스냅샷 프로세스"^] 클러스터 관리자가 다음을 생성할 수 있도록 합니다. `VolumeSnapshotContent` Trident 외부에서 생성된 객체 및 가져오기 스냅샷.

.시작하기 전에
Trident 스냅샷의 부모 볼륨을 생성하거나 가져와야 합니다.

.단계
. *클러스터 관리자:* 생성 `VolumeSnapshotContent` 백엔드 스냅샷을 참조하는 개체입니다.  이렇게 하면 Trident 에서 스냅샷 워크플로가 시작됩니다.
+
** 백엔드 스냅샷의 이름을 지정하세요. `annotations` ~처럼 `trident.netapp.io/internalSnapshotName: <"backend-snapshot-name">` .
** 지정하다 `<name-of-parent-volume-in-trident>/<volume-snapshot-content-name>` ~에 `snapshotHandle` . 이것은 외부 스냅샷터가 Trident 에 제공하는 유일한 정보입니다. `ListSnapshots` 부르다.
+

NOTE: 그만큼 `<volumeSnapshotContentName>` CR 명명 제약으로 인해 백엔드 스냅샷 이름과 항상 일치할 수는 없습니다.

+
.예
다음 예제에서는 다음을 생성합니다. `VolumeSnapshotContent` 백엔드 스냅샷을 참조하는 객체 `snap-01` .

+
[source, yaml]
----
apiVersion: snapshot.storage.k8s.io/v1
kind: VolumeSnapshotContent
metadata:
  name: import-snap-content
  annotations:
    trident.netapp.io/internalSnapshotName: "snap-01"  # This is the name of the snapshot on the backend
spec:
  deletionPolicy: Retain
  driver: csi.trident.netapp.io
  source:
    snapshotHandle: pvc-f71223b5-23b9-4235-bbfe-e269ac7b84b0/import-snap-content # <import PV name or source PV name>/<volume-snapshot-content-name>
  volumeSnapshotRef:
    name: import-snap
    namespace: default
----


. *클러스터 관리자:* 생성 `VolumeSnapshot` 참조하는 CR `VolumeSnapshotContent` 물체.  이것은 사용에 대한 액세스를 요청합니다. `VolumeSnapshot` 주어진 네임스페이스에서.
+
.예
다음 예제에서는 다음을 생성합니다. `VolumeSnapshot` CR이 명명됨 `import-snap` 참조하는 `VolumeSnapshotContent` 명명된 `import-snap-content` .

+
[source, yaml]
----
apiVersion: snapshot.storage.k8s.io/v1
kind: VolumeSnapshot
metadata:
  name: import-snap
spec:
  # volumeSnapshotClassName: csi-snapclass (not required for pre-provisioned or imported snapshots)
  source:
    volumeSnapshotContentName: import-snap-content
----
. *내부 처리(작업 필요 없음):* 외부 스냅샷터는 새로 생성된 것을 인식합니다. `VolumeSnapshotContent` 그리고 실행됩니다 `ListSnapshots` 부르다.  Trident 다음을 생성합니다. `TridentSnapshot` .
+
** 외부 스냅샷터는 다음을 설정합니다. `VolumeSnapshotContent` 에게 `readyToUse` 그리고 `VolumeSnapshot` 에게 `true` .
** Trident 돌아온다 `readyToUse=true` .


. *모든 사용자:* 만들기 `PersistentVolumeClaim` 새로운 것을 참조하기 위해 `VolumeSnapshot` , 여기서 `spec.dataSource` (또는 `spec.dataSourceRef` ) 이름은 `VolumeSnapshot` 이름.
+
.예
다음 예제에서는 다음을 참조하는 PVC를 생성합니다. `VolumeSnapshot` 명명된 `import-snap` .

+
[source, yaml]
----
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pvc-from-snap
spec:
  accessModes:
    - ReadWriteOnce
  storageClassName: simple-sc
  resources:
    requests:
      storage: 1Gi
  dataSource:
    name: import-snap
    kind: VolumeSnapshot
    apiGroup: snapshot.storage.k8s.io
----




== 스냅샷을 사용하여 볼륨 데이터 복구

스냅샷 디렉토리는 기본적으로 숨겨져 있어 볼륨 프로비저닝의 최대 호환성을 용이하게 합니다. `ontap-nas` 그리고 `ontap-nas-economy` 운전자.  활성화 `.snapshot` 스냅샷에서 직접 데이터를 복구할 수 있는 디렉토리입니다.

볼륨 스냅샷 복원 ONTAP CLI를 사용하여 볼륨을 이전 스냅샷에 기록된 상태로 복원합니다.

[listing]
----
cluster1::*> volume snapshot restore -vserver vs0 -volume vol3 -snapshot vol3_snap_archive
----

NOTE: 스냅샷 복사본을 복원하면 기존 볼륨 구성이 덮어쓰여집니다.  스냅샷 복사본이 생성된 후 볼륨 데이터에 적용된 변경 사항은 손실됩니다.



== 스냅샷에서 제자리 볼륨 복원

Trident 다음을 사용하여 스냅샷에서 빠르고 정확한 볼륨 복원을 제공합니다. `TridentActionSnapshotRestore` (TASR) CR.  이 CR은 필수 Kubernetes 작업으로 작동하며 작업이 완료된 후에는 유지되지 않습니다.

Trident 스냅샷 복원을 지원합니다. `ontap-san` , `ontap-san-economy` , `ontap-nas` , `ontap-nas-flexgroup` , `azure-netapp-files` , `gcp-cvs` , `google-cloud-netapp-volumes` , 그리고 `solidfire-san` 운전자.

.시작하기 전에
바인딩된 PVC와 사용 가능한 볼륨 스냅샷이 있어야 합니다.

* PVC 상태가 바인딩되었는지 확인하세요.
+
[source, console]
----
kubectl get pvc
----
* 볼륨 스냅샷을 사용할 준비가 되었는지 확인하세요.
+
[source, console]
----
kubectl get vs
----


.단계
. TASR CR을 생성합니다.  이 예제에서는 PVC에 대한 CR을 생성합니다. `pvc1` 및 볼륨 스냅샷 `pvc1-snapshot` .
+

NOTE: TASR CR은 PVC 및 VS가 있는 네임스페이스에 있어야 합니다.

+
[source, console]
----
cat tasr-pvc1-snapshot.yaml
----
+
[source, yaml]
----
apiVersion: trident.netapp.io/v1
kind: TridentActionSnapshotRestore
metadata:
  name: trident-snap
  namespace: trident
spec:
  pvcName: pvc1
  volumeSnapshotName: pvc1-snapshot
----
. 스냅샷에서 복원하려면 CR을 적용합니다.  이 예제는 스냅샷에서 복원합니다. `pvc1` .
+
[source, console]
----
kubectl create -f tasr-pvc1-snapshot.yaml
----
+
[listing]
----
tridentactionsnapshotrestore.trident.netapp.io/trident-snap created
----


.결과
Trident 스냅샷에서 데이터를 복원합니다.  스냅샷 복원 상태를 확인할 수 있습니다.

[source, console]
----
kubectl get tasr -o yaml
----
[source, yaml]
----
apiVersion: trident.netapp.io/v1
items:
- apiVersion: trident.netapp.io/v1
  kind: TridentActionSnapshotRestore
  metadata:
    creationTimestamp: "2023-04-14T00:20:33Z"
    generation: 3
    name: trident-snap
    namespace: trident
    resourceVersion: "3453847"
    uid: <uid>
  spec:
    pvcName: pvc1
    volumeSnapshotName: pvc1-snapshot
  status:
    startTime: "2023-04-14T00:20:34Z"
    completionTime: "2023-04-14T00:20:37Z"
    state: Succeeded
kind: List
metadata:
  resourceVersion: ""
----
[NOTE]
====
* 대부분의 경우, Trident 실패 시 자동으로 작업을 다시 시도하지 않습니다.  작업을 다시 수행해야 합니다.
* 관리자 액세스 권한이 없는 Kubernetes 사용자는 애플리케이션 네임스페이스에 TASR CR을 생성하기 위해 관리자로부터 권한을 부여받아야 할 수도 있습니다.


====


== 연관된 스냅샷이 있는 PV 삭제

연관된 스냅샷이 있는 영구 볼륨을 삭제하면 해당 Trident 볼륨이 "삭제 중 상태"로 업데이트됩니다.  볼륨 스냅샷을 제거하여 Trident 볼륨을 삭제합니다.



== 볼륨 스냅샷 컨트롤러 배포

Kubernetes 배포판에 스냅샷 컨트롤러와 CRD가 포함되어 있지 않으면 다음과 같이 배포할 수 있습니다.

.단계
. 볼륨 스냅샷 CRD를 생성합니다.
+
[listing]
----
cat snapshot-setup.sh
----
+
[source, sh]
----
#!/bin/bash
# Create volume snapshot CRDs
kubectl apply -f https://raw.githubusercontent.com/kubernetes-csi/external-snapshotter/release-6.1/client/config/crd/snapshot.storage.k8s.io_volumesnapshotclasses.yaml
kubectl apply -f https://raw.githubusercontent.com/kubernetes-csi/external-snapshotter/release-6.1/client/config/crd/snapshot.storage.k8s.io_volumesnapshotcontents.yaml
kubectl apply -f https://raw.githubusercontent.com/kubernetes-csi/external-snapshotter/release-6.1/client/config/crd/snapshot.storage.k8s.io_volumesnapshots.yaml
----
. 스냅샷 컨트롤러를 생성합니다.
+
[source, console]
----
kubectl apply -f https://raw.githubusercontent.com/kubernetes-csi/external-snapshotter/release-6.1/deploy/kubernetes/snapshot-controller/rbac-snapshot-controller.yaml
----
+
[source, console]
----
kubectl apply -f https://raw.githubusercontent.com/kubernetes-csi/external-snapshotter/release-6.1/deploy/kubernetes/snapshot-controller/setup-snapshot-controller.yaml
----
+

NOTE: 필요한 경우 열어주세요 `deploy/kubernetes/snapshot-controller/rbac-snapshot-controller.yaml` 그리고 업데이트 `namespace` 네임스페이스에.





== 관련 링크

* link:../trident-concepts/snapshots.html["볼륨 스냅샷"]
* link:../trident-reference/objects.html["볼륨 스냅샷 클래스"]

